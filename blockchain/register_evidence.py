import os
import json
import time
from web3 import Web3
from web3.middleware import geth_poa_middleware
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# --- Configuration from Environment Variables ---
# Polygon Mumbai Testnet RPC URL (or other network)
RPC_URL = os.getenv("RPC_URL", "https://polygon-mumbai.g.alchemy.com/v2/YOUR_ALCHEMY_API_KEY")
# Your wallet's private key (NEVER hardcode this in production)
PRIVATE_KEY = os.getenv("PRIVATE_KEY")
# Address of the deployed EvidenceRegistry contract
CONTRACT_ADDRESS = os.getenv("CONTRACT_ADDRESS")

# Path to the compiled contract ABI (generated by Hardhat)
ABI_PATH = os.path.join(os.path.dirname(__file__), "artifacts", "EvidenceRegistry.json")

# --- Web3 Setup ---
w3 = Web3(Web3.HTTPProvider(RPC_URL))

# Check if connected to Ethereum node
if not w3.is_connected():
    print(f"Error: Could not connect to Web3 provider at {RPC_URL}")
    exit()

# For PoA networks like Polygon, inject the PoA middleware
w3.middleware_onion.inject(geth_poa_middleware, layer=0)

# Load contract ABI
try:
    with open(ABI_PATH, 'r') as f:
        contract_json = json.load(f)
    CONTRACT_ABI = contract_json['abi']
except FileNotFoundError:
    print(f"Error: ABI file not found at {ABI_PATH}. Please compile your contract first.")
    exit()
except json.JSONDecodeError:
    print(f"Error: Could not decode JSON from ABI file at {ABI_PATH}.")
    exit()

# Create contract instance
contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=CONTRACT_ABI)

def register_evidence(evidence_hash_bytes32: bytes, metadata: str, retries: int = 3, delay: int = 5) -> str | None:
    """
    Registers evidence on the blockchain.

    Args:
        evidence_hash_bytes32: The SHA-256 hash of the evidence as bytes32.
        metadata: A string containing additional metadata about the evidence.
        retries: Number of times to retry the transaction if it fails.
        delay: Delay in seconds between retries.

    Returns:
        The transaction hash if successful, None otherwise.
    """
    if not PRIVATE_KEY:
        print("Error: PRIVATE_KEY not set in environment variables.")
        return None

    account = w3.eth.account.from_key(PRIVATE_KEY)
    nonce = w3.eth.get_transaction_count(account.address)

    print(f"Attempting to register evidence with hash: {evidence_hash_bytes32.hex()} and metadata: '{metadata}'")

    for attempt in range(retries):
        try:
            # Estimate gas for the transaction
            # This helps ensure the transaction has enough gas and avoids 'out of gas' errors.
            # It's good practice to add a buffer to the estimated gas.
            estimated_gas = contract.functions.registerEvidence(evidence_hash_bytes32, metadata).estimate_gas({
                'from': account.address,
                'nonce': nonce + attempt
            })
            gas_limit = int(estimated_gas * 1.2) # Add 20% buffer

            # Get current gas price (for Polygon, EIP-1559 is common, but legacy tx also works)
            # For EIP-1559, you'd typically fetch maxFeePerGas and maxPriorityFeePerGas
            # For simplicity, using legacy gas price here.
            gas_price = w3.eth.gas_price

            transaction = contract.functions.registerEvidence(evidence_hash_bytes32, metadata).build_transaction({
                'from': account.address,
                'nonce': nonce + attempt,
                'gas': gas_limit,
                'gasPrice': gas_price,
                'chainId': w3.eth.chain_id
            })

            signed_txn = w3.eth.account.sign_transaction(transaction, private_key=PRIVATE_KEY)
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            print(f"Transaction sent. Hash: {tx_hash.hex()}")

            # Wait for the transaction to be mined
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=300) # 5 minute timeout
            if receipt.status == 1:
                print(f"Transaction successful! Block number: {receipt.blockNumber}")
                return tx_hash.hex()
            else:
                print(f"Transaction failed in block {receipt.blockNumber}. Receipt: {receipt}")
                if attempt < retries - 1:
                    print(f"Retrying in {delay} seconds...")
                    time.sleep(delay)
        except Exception as e:
            print(f"Attempt {attempt + 1} failed: {e}")
            if "already registered" in str(e):
                print("Evidence already registered on-chain. Aborting retries.")
                return None # Or retrieve existing tx hash if needed
            if attempt < retries - 1:
                print(f"Retrying in {delay} seconds...")
                time.sleep(delay)
    print(f"Failed to register evidence after {retries} attempts.")
    return None

def verify_evidence(evidence_hash_bytes32: bytes) -> dict | None:
    """
    Verifies evidence on the blockchain.

    Args:
        evidence_hash_bytes32: The SHA-256 hash of the evidence as bytes32.

    Returns:
        A dictionary containing evidence details if found, None otherwise.
    """
    try:
        # Call the view function
        evidence_details = contract.functions.verifyEvidence(evidence_hash_bytes32).call()
        # The return type is a tuple, convert to a more readable dictionary
        return {
            "evidenceHash": evidence_details[0].hex(),
            "metadata": evidence_details[1],
            "owner": evidence_details[2],
            "timestamp": evidence_details[3],
            "blockNumber": evidence_details[4],
            "transactionHash": evidence_details[5].hex()
        }
    except Exception as e:
        if "Evidence not found" in str(e):
            print(f"Evidence with hash {evidence_hash_bytes32.hex()} not found on chain.")
        else:
            print(f"Error verifying evidence: {e}")
        return None

if __name__ == "__main__":
    # Example Usage:
    # Replace with your actual evidence hash (must be 32 bytes) and metadata
    sample_hash_str = "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2"
    sample_metadata = "CCTV footage of incident #123 from camera 5"

    # Convert hex string to bytes32
    sample_hash_bytes32 = bytes.fromhex(sample_hash_str)

    # Register evidence
    tx_hash = register_evidence(sample_hash_bytes32, sample_metadata)
    if tx_hash:
        print(f"Evidence registration successful! Transaction Hash: {tx_hash}")
    else:
        print("Evidence registration failed or already exists.")

    print("\n--- Verifying Evidence ---")
    # Verify evidence
    verified_data = verify_evidence(sample_hash_bytes32)
    if verified_data:
        print("Verified Evidence Details:")
        for key, value in verified_data.items():
            print(f"  {key}: {value}")
    else:
        print("Could not verify evidence.")
